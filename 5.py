# -*- coding: utf-8 -*-
"""ScientificComputingWithPython_Exercise5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17L7bbnMhsWJQDf67cnak_D70Gg7smV8S

# ***Intro:***
"""

!wget https://www.dropbox.com/s/xvjzaxzz3ysphme/data_000637.txt -P ./data/

import pandas as pd
file_name = "./data/data_000637.txt"
data = pd.read_csv(file_name)
data

"""# ***Exe.1:***
Create a Pandas DataFrame reading N rows of the data/data_000637.txt dataset. Choose N to be smaller than or equal to the maximum number of rows and larger that 10k (check the documentation).
"""

MaximumNumberOfRows = len(data)
print("The maximum number of rows is:" , MaximumNumberOfRows)
print(data.axes[0])
print("We need to choose our N such that be smalle than or equal to the maxmimum number of rows and larger than 10k.")
print("We can consider N as: 100000.")
print("Now is the time to create DataFrame.")
df = data.sample(n = 100000)
df.shape

"""# ***Exe.2:***
Estimate the number of BX in a ORBIT (the value x)
"""

Maximum = df["BX_COUNTER"].max()
print("The maximum number of BX in a ORBIT is: " , Maximum)
print("So we can understand the maximum number of BX before reaching 0 is: " , Maximum)

"""# ***Exe.3:***
Create a new column with the absolute time in ns (as a combination of the other three columns with timing information) since the beginning of the data acquisition, and convert the new column to a Time Series.
"""

import datetime as dt
T = 25/30
S = 25*3563
df["NewTimeSeries"] = ( df["TDC_MEAS"] * T ) + ( df["BX_COUNTER"] * 25 ) + ( df["ORBIT_CNT"] * S )
date = dt.date.today()
tstamp = pd.Timestamp(date)
print("TimeStamp:", tstamp.value)
print(pd.Timestamp(tstamp.value,unit = "ns"))
def TimeStamp(x):
  return pd.Timestamp(x , unit = "ns")
df["NewTimeSeries"] = df["NewTimeSeries"].apply(TimeStamp)
print(df.iloc[1,:])
print(df.head())

"""# ***Exe.4:***
Find out the duration of the data taking in hours, minutes and seconds, by using the features of the Time Series. Perform this check reading the whole dataset.
"""

#In order to not change the original object it is better to use the copy of the DataFrame
Newdf = df.copy()
sorted= Newdf.sort_values(by = "NewTimeSeries")["NewTimeSeries"]
print(sorted.shape)
print('d',sorted.iloc[0])
print('d',sorted.iloc[99999])
print(type(sorted))
print(sorted)

Difference = sorted.iloc[99999] - sorted.iloc[0]
print(Difference)

"""# ***Exe.5:***
Use the .groupby() method to find out the noisy channels, i.e. the TDC channels with most counts (print to screen the top 3 and the corresponding counts)
"""

import pandas as pd
ChannelsWithNoise = df.groupby('TDC_CHANNEL').count()
print(ChannelsWithNoise)

#Now want the top 3 noisy channels
import numpy as np
OrderOfNoisyChannels = ChannelsWithNoise.sort_values(by = 'HEAD', ascending = False)
print("Top 3 of channels with noise: ")
print("")
print(OrderOfNoisyChannels.iloc[:3,:])
print("")
print("The values of top 3 are: " , OrderOfNoisyChannels.iloc[:3,:].index )
a = OrderOfNoisyChannels.iloc[:3,:].index
Count = OrderOfNoisyChannels.index.values
print("The Count of non zero is : (Eqivalent to unique values) ", np.count_nonzero(Count))

"""# ***Exe.6:***
Count the number of non-empty orbits (i.e. the number of orbits with at least one hit).
"""

import pandas as pd
Count = df['ORBIT_CNT'].unique()
print(df['ORBIT_CNT'].isnull().sum())

"""# ***Exe.7:***

Count the number of unique orbits with at least one measurement from TDC_CHANNEL=139.
"""

#For solvong this we can use query
query = df.query('TDC_CHANNEL == 139')
print("Our query is: \n" , query)
UniqeOrbit=query['ORBIT_CNT'].unique()
print("The unique orbits:" , UniqeOrbit)
#Now is time to count the unique orbits
UniqeOrbitsCount=query['ORBIT_CNT'].unique().shape
print("Count of unique orbits with at least one measurement from TDC_CHANNEL = 139 :" , UniqeOrbitsCount)

"""# ***Exe.8:***
Create two Series (one for each FPGA) that have the TDC channel as index, and the number of counts for the corresponding TDC channel as values.
"""

q = df.query('FPGA == 0')
FirstSeries = q.value_counts(df['TDC_CHANNEL'])
print("First Series: \n" , FirstSeries)
print("The shape of counts for the first TDC channel: " , df['TDC_CHANNEL'].value_counts().shape)
print("The second value is the count.")

q = df.query('FPGA == 1')
SecondSeries = q.value_counts(df['TDC_CHANNEL'])
print("Second Series: \n" , SecondSeries)
print("The shape of counts for the second TDC channel: " , df['TDC_CHANNEL'].value_counts().shape)
print("The second value is the count.")