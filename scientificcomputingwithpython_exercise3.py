# -*- coding: utf-8 -*-
"""ScientificComputingWithPython_Exercise3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EBUTolbhg0sofZSefX0waEKTgUtW0Ck4

# ***Problem No1. Number representation:***

Write a function that converts numbers among the bin, dec, and hex representations (bin<->dec<->hex). Determine the input type in the function, and pass another argument to choose the output representation.
"""

#Converting straightforward using casting (Solution1)
def Change(x):
  try:
    Type = type(x)
  except:
    Type = "Hexadecimal"
  if Type == "Binary":
    m = hex(int(x))
    n = int(x, 2)
    return 'Hexadecimal representation of', x, ':', m,'And','Decimal representation of', x, ':', n
  elif Type == "Hexadecimal":
    n = int(x, 2)
    m = bin(n)
    return 'Binary representation of', x, ':', m,'And','Decimal representation of', x, ':', n
  else:
    x = int(x)
    m = hex(x)
    n = bin(x)
    return 'Hexadecimal representation of', x, ':', m,'And','Binary representation of', x, ':', n

x = input("Enter The value:")
print(Change(x))

#Converting straightforward using casting (Solution2)
def Change(x,y):
  try:
    Type = type(x)
  except:
    Type = "Hexadecimal"
  if Type == "Binary":
    m = hex(int(x))
    n = int(x, 2)
    if ( y == "Binary"):
      return 'The Type of x (input number) is Binary and the output will be the same as the input. So the output is:',x
    elif (y == "Decimal"):
      return 'Decimal representation of', x, ':', n
    else:
      return 'Hexadecimal representation of', x, ':', m
  elif Type == "Hexadecimal":
    n = int(x, 2)
    m = bin(n)
    if (y == "Hexadecimal"):
      return 'The Type of x (input number) is Hexadecimal and the output will be the same as the input. So the output is:',x
    elif (y == "Decimal"):
      return 'Decimal representation of', x, ':', n
    else:
      return 'Binary representation of', x, ':', m
  else:
    x = int(x)
    m = hex(x)
    n = bin(x)
    if (y == "Decimal"):
      return 'The Type of x (input number) is Decimal and the output will be the same as the input. So the output is:',x
    elif (y == "Binary"):
      return 'Binary representation of', x, ':', n
    else:
      return 'Hexadecimal representation of', x, ':', m

x = input("Enter The value: ")
y = input("Enter what type of output do you want? (Choosing from Decimal , Binary , Hexadecimal)? ")
print(Change(x,y))

"""# ***Problem No2. 32-bit floating point number:***

Write a function that converts a 32 bit binary string (for example, 110000101011000000000000) into a single precision floating point in decimal representation. Interpret the various bits as sign, fractional part of the mantissa and exponent, according to the IEEE 754 reccommendations.
"""

def ConvertBinToFloat(MantissaString):
    PowerCount = -1
    MantissaFloat = 0
    for i in MantissaString:
        MantissaFloat += (int(i) * pow(2, PowerCount))
        PowerCount = PowerCount - 1
    return (MantissaFloat + 1)
 
if __name__ == "__main__":
    IEEE32 = input("Enter Binary string: ")
    SignBit = int(IEEE32[0])
    ExponentBias = int(IEEE32[2 : 10], 2)
    ExponentUnBias = ExponentBias - 127
    MantissaString = IEEE32[11 : ]
    MantissaFloat = ConvertBinToFloat(MantissaString)
    FloatingNumber = pow(-1, SignBit) * MantissaFloat * pow(2, ExponentUnBias)
    print("The float value of the given IEEE-754 representation is :",FloatingNumber)

"""# ***Problem No3. Underflow and overflow:***

Write a program to determine the underflow and overflow limits (within a factor of 2) for floating point numbers on your computer.

Hint: define two variables initialized to 1, and halve/double them for a sufficient amount of times to exceed the under/over-flow limits.
"""

import sys
UnderFlow = 1
OverFlow = 1
NumberOfReapet = 0
m = sys.float_info.dig #Maximum number of decimal digits that can be faithfully represented in a float
#print(m)
for i in range(m):
    OverFlow  = OverFlow  * 2
    UnderFlow = UnderFlow / 2
    NumberOfReapet  += 1

ShorterOverFlow = "{:e}".format(OverFlow)
ShorterUnderFlow = "{:e}".format(UnderFlow)

print("Maximum number of decimal digits that can be faithfully represented in a float is: " , m)
print("With the number of reapet",NumberOfReapet,"We reach to what we want. And the overflow is:" , ShorterOverFlow, ", And the underflow is:", ShorterUnderFlow)

#ُSolution number 2: (Using self Tests)
UnderFlow = 1
OverFlow = 1
NumberOfReapet = 0

for i in range(1023):  #1023 Based on test I have done. IF we put 1024 we will get error and with 1022 the numbers are not good!
    OverFlow  = OverFlow  * 2
    UnderFlow = UnderFlow / 2
    NumberOfReapet  += 1

ShorterOverFlow = "{:e}".format(OverFlow)
ShorterUnderFlow = "{:e}".format(UnderFlow)

print("With the number of reapet",NumberOfReapet,"We reach to what we want. And the overflow is:" , ShorterOverFlow, ", And the underflow is:", ShorterUnderFlow)

"""# ***Problem No4. Machine precision:***

Similarly to the previous exercise, write a program to determine the machine precision for floating point numbers.

Hint: define a new variable by adding an increasingly smaller value and check when the addition starts to have no effect on the number.
"""

Variable = 2
SmallNumber = 2e-4
print("The small number is:", SmallNumber)
for i in range(1,16):
    Variable = Variable + SmallNumber
    SmallNumber = SmallNumber * SmallNumber
    print(f'Step {i}:',Variable )
print("We see after 3 steps it won't have any effect on the number.")

"""# ***Problem No5. Quadratic solution:***

Write a function that takes in input three parameters ,  and  and prints out the two solutions to the quadratic equation 
 using the standard formula:
 

use the function to compute the solution
"""

# Test function :)
import math
def SolveEquation(a,b,c):
  x = -b
  Delta = (b ** 2) - 4 * a * c
  SqrtDelta = Delta ** 0.5
  x1 = x + SqrtDelta / 2*a
  x2 = x - SqrtDelta / 2*a
  return 'The two answers are: ', x1 , x2
a = int(input("Enter the first number (a): "))
b = int(input("Enter the first number (b): "))
c = int(input("Enter the first number (c): "))
print("Our answers to equation (a*x^2 + b*x + c = 0) are --> ",SolveEquation(a,b,c))

"""write a function that computes the roots of a quadratic equation accurately in all cases:"""

from math import sqrt
def SolveEquation(a,b,c):
  x = -b
  Delta = (b ** 2) - 4 * a * c
  if Delta > 0:
     SqrtDelta = Delta ** 0.5
     x1 = float(x + SqrtDelta / 2*a)
     x2 = float(x - SqrtDelta / 2*a)
     return "There are 2 roots: %2f and %2f" % (x1, x2)
  elif Delta < 0:
     return "There is no such root with Real value."
  elif Delta == 0 :
      SqrtDelta = Delta ** 0.5
      x1 = x + SqrtDelta / 2*a
      return "There is just one root: %f" % (x1)

a = float(input("Enter the first number (a): "))
b = float(input("Enter the first number (b): "))
c = float(input("Enter the first number (c): "))
print("Our answers to equation (a*x^2 + b*x + c = 0) are --> ",SolveEquation(a,b,c))

# Re-express the formula 
# We know the delta is positive in this case bacause of previous calculation so we skip the consideration of delta in this code.
import math
def ReExpressEquation(a,b,c):
  x = -b
  Delta = (b ** 2) - 4 * a * c
  SqrtDelta = Delta ** 0.5
  z = float(x + SqrtDelta)
  z2 = z ** 2
  y = float(x - SqrtDelta)
  y2 = y ** 2
  x1 = z2 / 2*a*z
  x2 = y2 / 2*a*y
  return 'The two answers are: ', x1 , x2
a = float(input("Enter the first number (a): "))
b = float(input("Enter the first number (b): "))
c = float(input("Enter the first number (c): "))
print("Our answers to equation (a*x^2 + b*x + c = 0) are --> ", ReExpressEquation(a,b,c))
print("Because we consider big numbers the output even with little changes will change alot.")
print("So we can understand that the calculation of the equation with standard form is unstable.")

"""write a function that computes the roots of a quadratic equation accurately in all cases."""

# For computing the accurate roots we should use the hex()
# The function float.hex() yield the exact value stored for a floating point number

from math import sqrt
def SolveEquation(a,b,c):
  x = -b
  Delta = (b ** 2) - 4 * a * c
  if Delta > 0:
     SqrtDelta = Delta ** 0.5
     x1 = float(x + SqrtDelta / 2*a)
     x1 = x1.hex()
     x2 = float(x - SqrtDelta / 2*a)
     x2 = x2.hex()
     return "There are 2 roots:" , (x1,x2)
  elif Delta < 0:
     return "There is no such root with Real value."
  elif Delta == 0 :
      SqrtDelta = Delta ** 0.5
      x1 = x + SqrtDelta / 2*a
      return "There is just one root: " , (x1)

a = float(input("Enter the first number (a): "))
b = float(input("Enter the first number (b): "))
c = float(input("Enter the first number (c): "))
print("Our answers to equation (a*x^2 + b*x + c = 0) are --> ",SolveEquation(a,b,c))

"""# ***Problem No6. The derivative:***

Write a program that implements the function f(x) = x(x-1)
"""

def Function1(x):
  return "The output of function (f(x) = x(x-1)) is: ", x * (x-1)
print(Function1(int(input("Enter a number: "))))

def Function(m,x):
  if m == 0:
    function = x * (x-1)
    return function
  else:
    function = ((x + m) * (x + m - 1)) - (x * (x-1))
    return function

"""Calculate the derivative of the function at the point  using the derivative definition:with Calculate the true value of the same derivative analytically and compare it with the answer your program gives. The two will not agree perfectly. Why?"""

#Answer of the program:
from sympy import limit, Symbol 
x = Symbol('x')
m = 0.01
x = 1
if m == 0:
  Function = x * (x-1)
else:
  Function = ((x + m) * (x + m - 1)) - (x * (x-1))
y =  Function / m
limit(y, x, 0)

"""If we want to calculate the true value the derivation of f(x) will be (2x - 1).
So with x = 1, Our exact answer should be 1 but the program gives 1.01 instead of 1.
"""

#Answer of the program with smaller m
from sympy import limit, Symbol 
x = Symbol('x')
m = 0.0001
x = 1
if m == 0:
  Function = x * (x-1)
else:
  Function = (x + m) * (x + m - 1)
y =  Function / m
limit(y, x, 0)

#Answer of the program with smaller m
from sympy import limit, Symbol 
x = Symbol('x')
m = 0.000001
x = 1
if m == 0:
  Function = x * (x-1)
else:
  Function = (x + m) * (x + m - 1)
y =  Function / m
limit(y, x, 0)

"""We can see that how much we reduce the m our accuracy increase and we get near by the complete correct answer step by step, slowly!

# ***Problem No7. Integral of a semicircle:***

(a) Write a program to compute the integral with N = 100. How does the result compare to the true value?
"""

# In this exercise we need to calculate the integral. And this integral is the area below the line of f(x).
# In the Riemann definition we have many rectangles and we should calculate the area of each of them and then accumulate them in sum variable. The limitation of this sum is equal to integral

import math 
def Function(N):
    UpperLimit = 1
    LowerLimit = -1  
    h = (UpperLimit - LowerLimit) / N  # Our domain is the difference between the upperlimit and the lowerlimit. in order to calculate the length of the rectangle we need to divide this domain length to the number of rectangle that we have
    # h = abs(UpperLimit - LowerLimit) / N  (If we want to be sure that we calculate the positive value of the domain) ((1-(-1) = 2)/ N)
    I = 0 
    for k in range(N):
        x = LowerLimit + h * k
        yk = math.sqrt(1 - x**2)
        I += h * yk
    return I
    
print(Function(100))
print(math.pi/2)

"""(b) How much can N be increased if the computation needs to be run in less than a second? What is the gain in running it for 1 minute? Use timeit to measure the time."""

# In order to calculate the time I consider the time before starting the function and the time after function. Then reduce the start time from finish time
import math
import timeit
StartTime = timeit.default_timer()
def Function(N):
    UpperLimit = 1
    LowerLimit = -1  
    h = (UpperLimit - LowerLimit) / N  # Our domain is the difference between the upperlimit and the lowerlimit. in order to calculate the length of the rectangle we need to divide this domain length to the number of rectangle that we have
    # h = abs(UpperLimit - LowerLimit) / N  (If we want to be sure that we calculate the positive value of the domain)
    I = 0 
    for k in range(N):
        x = LowerLimit + h * k
        yk = math.sqrt(1 - x**2)
        I += h * yk
    return I

N = 2900000
Function(N)
EndTime = timeit.default_timer()
print("With the Number N of", N,"The function time is:" , EndTime - StartTime)
print("Maybe we can increase our N a little bit to get closer to 1 sec but in general time changes everytime we run our code so sometimes we need to increase it or decrese it to be approximately near 1  :) ")

# In order to calculate the time I consider the time before starting the function and the time after function. Then reduce the start time from finish time
import math
import timeit
StartTime = timeit.default_timer()
def Function(N):
    UpperLimit = 1
    LowerLimit = -1  
    h = (UpperLimit - LowerLimit) / N  # Our domain is the difference between the upperlimit and the lowerlimit. in order to calculate the length of the rectangle we need to divide this domain length to the number of rectangle that we have
    # h = abs(UpperLimit - LowerLimit) / N  (If we want to be sure that we calculate the positive value of the domain)
    I = 0 
    for k in range(N):
        x = LowerLimit + h * k
        yk = math.sqrt(1 - x**2)
        I += h * yk
    return I

N = 180000000
Function(N)
EndTime = timeit.default_timer()
print("With the Number N of", N,"The function time is:" , EndTime - StartTime)
print("Maybe we can increase our N a little bit to get closer to 1 minute but in general time changes everytime we run our code so sometimes we need to increase it or decrese it to be approximately near 1  :) ")