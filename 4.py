# -*- coding: utf-8 -*-
"""ScientificComputingWithPython_Exercise4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-85K4ZjxhPjuh56_QcCVQ-zilAMabvU5

# ***Exe.1:***
"""

import numpy as np
m = np.arange(12).reshape((3,4))
print(m)
print("The mean of the matrix is: ", m.mean())
print("The mean on the columns: ", m.mean(axis = 0))
print("the mean on the rows: ", m.mean(axis = 1))

"""# ***Exe.2:***"""

import numpy as np
u = np.array([1, 3, 5, 7])
v = np.array([2, 4, 6, 8])
print("The original matrix u is:", u)
print("The original matrix v is:",v)
print("")

#Using the function outer in numpy
print("The outer product using numpy is: \n",np.outer(u,v))
print("")

#Using a nested for loop or a list comprehension
a = []
for i in range(len(u)):
  for j in range(len(v)):
    a.append(np.dot(u[i],v[j]))
a = np.array(a)
b = a.reshape(4,4)
print("The outer product using for and list is: \n", b)
print("")

#Using numpy broadcasting operations
print("The outer product using broadcasting: \n",u[:, np.newaxis] * v)

"""# ***Exe.3:***"""

import numpy as np
a = np.random.uniform(0,3,[10,6])
print("Our random (10,6) matrix over 0 to 3 is: \n" , a)
print("")
a[a < 0.3] = 0
print("Our random matrix after applying mask ([ < 0.3] = 0 is: \n" , a)

"""# ***Exe.4:***"""

import math
import numpy as np
a = np.linspace(0 , 2* np.pi , 100)
print("Our arrays is: \n" , a)
print("")
print("Every 10th element using the slice notation is: \n", a[0:100:10])
print("")
print("The reverse using the slice notation is: \n" , a[::-1])
print("")
l = []
for x in a:
  SinX = np.sin(x)
  CosX = np.cos(x)
  if abs(SinX - CosX) < 0.1:
    l.append(x)
b = np.array(l)   
print("Elements where the absolute difference between the sin and cos functions evaluated for that element is < 0.1: \n ",  b) 
print("")

#Optional:
print("A plot showing the sin and cos functions and indicate where they are close: ")
print("The red plot is sin and the blue one is cos")
import matplotlib.pylab as plt
x = a
plt.plot(x, np.sin(x),"r")
plt.plot(x, np.cos(x) , "b")
plt.xlabel('Angle [rad]')
plt.ylabel('values')
plt.show()

"""# ***Exe.5:***"""

import numpy as np

def MultiplicationTable(n):
    range = np.arange(1,n+1)
    return range * range[:, None]
b = MultiplicationTable(10)
print("The multiplication table of 10 * 10 is:\n" , b)
print("The trace of the matrix is:" , np.trace(MultiplicationTable(10)))
def AntiDiagonal(b):
    return np.fliplr(b).diagonal()
print("The anti-diagonal of the matrix is: " , AntiDiagonal(b))
c = b.diagonal(1)
print("The diagonal offset by 1 upwards is:" , c)

"""# ***Exe.6:***"""

import numpy as np
import math
cities = "Chicago, Springfield, Saint-Louis, Tulsa, Oklahoma City, Amarillo, Santa Fe, Albuquerque, Flagstaff, Los Angeles."
m = np.array([0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448])
print(m)
print("")
r = []
for i in m:
  r.append(abs(m - i))
r =  np.array(r)
print("The 2D grid of distances among each city along Route 66 is: \n", r)
print("")
e = m.reshape((10,1))
print("Using broadcasting: \n",e)
km = 1.60934
print("")
print("Convertion the distances in km is: \n", r * km)

"""# ***Exe.7:***"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np

prime = np.ones((100,), dtype=bool)
prime[:2] = 0

#SieveOfEratosthenes: (First start from 2 and its multiples and then 3 and ....)
max = int(np.sqrt(len(prime))) #Equal to if we consider x * x < n 
for i in range(2, max):
    prime[2*i::i] = False
a = np.nonzero(prime)
print("The prime numbers are: \n" , a)
print("")
print("A shape (N,) boolean array, which is the mask (0 and 1 are not prime so equal to False): \n" , prime)\

#This part is for estimating the time: (Like the other exercises :) )
#Consider a function from procedire abow

def SieveOfEratosthenes(n):
  prime = np.ones((n,), dtype=bool)
  prime[:2] = 0
  max = int(np.sqrt(len(prime))) #Equal to if we consider x * x < n 
  for i in range(2, max):
    prime[2*i::i] = False
  a = prime

print("")
#Apply the mask:
print("If N = 10, The time is: ")
# %timeit [SieveOfEratosthenes(10)]
print("If N = 100, The time is: ")
# %timeit [SieveOfEratosthenes(100)]
print("If N = 10000, The time is: ")
# %timeit [SieveOfEratosthenes(10000)]

print("")
print("We can conclude that how much we increase the max of numbers the time increases too, So they have straigth relation.")

"""# ***Exe.8:***"""

#A walker jumps right or left (+1 or -1) with equal probability so the p(right) = p(left) = 1/2
import numpy as np
#A 2D array where each row represents a walker, and each column represents a time step:
def Walker(walkers,steps):
  print("The distance that every" , walkers , "walkers go in number of steps" , steps, "is equal to:")
  Distance=[] #return the distance after the given time
  a = np.zeros((walkers,steps)) #Make a 2D array from walkers and steps
  for i in range(a.shape[0]): 
    RandomlyRightOrLeft = np.random.randint(-1 , 1 , steps) #Randomly choose right or left
    RandomlyRightOrLeft[RandomlyRightOrLeft == 0] = 1
    for j in range(RandomlyRightOrLeft.shape[0]):
      a[i][j] = RandomlyRightOrLeft[j]
  for i in range(a.shape[0]):
    b = a[i].sum() #sum all distances for one walker
    Distance.append(b) 
  return(Distance)

#Take 1000 walkers and let them walk for 200 steps
Walker(1000,200)

#Take the square of the previously-obtained array (element-wise).
l = np.array(Walker(1000,200))
s = np.power(l,2)
#Or s = np.multiply(l,l)
print(s)

#Compute the mean of the squared distances at each step (i.e. the mean along the columns)
#Using the previous function with some change to calculate the mean of squared distances...
def NewWalker(walkers,steps):
  Distance = [] #return the distance after the given time
  mean = []
  a = np.zeros((walkers,steps)) #Make a 2D array from walkers and steps
  for i in range(a.shape[0]): 
    RandomlyRightOrLeft = np.random.randint(-1 , 1 , steps) #Randomly choose right or left
    RandomlyRightOrLeft[RandomlyRightOrLeft == 0] = 1
    for j in range(RandomlyRightOrLeft.shape[0]):
      a[i][j] = RandomlyRightOrLeft[j]
  c = a.shape[0]
  for i in range(c):
    b = a[i].sum() #sum all distances for one walker
    s = np.power(b,2)
    OurMean = s / c
    mean.append(OurMean)
  return mean

print("The mean of the squared distances at each step:\n" , NewWalker(1000,200))

"""***Optional:***"""

import numpy as np
import matplotlib.pyplot as plt
import math
walkers = 1000
steps = 200
RandomlyRightOrLeft = 2 * np.random.random_integers(0,1,(walkers, steps)) - 1 
Distance = np.cumsum(RandomlyRightOrLeft, axis = 1)
msd = np.mean(pow(Distance , 2), axis = 0)
plt.figure(figsize = (10, 10))
plt.plot(np.arange(steps), msd)
plt.xlabel('Number of Steps(Time)')
plt.ylabel('Distances')